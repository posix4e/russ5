default_platform(:ios)

platform :ios do
  # Validate certificates and profiles
  desc "Verify certificates and profiles access"
  lane :verify_certificates do
    # Validate required environment variables
    validate_required_env_vars
    
    # Verify access to certificates repository
    UI.message("Verifying access to certificates repository...")
    
    # Use match to verify access to certificates
    match(
      type: "development",
      app_identifier: ["xyz.russ.russ5", "xyz.russ.russ5.Extension"],
      readonly: true,
      verbose: true
    )
    
    # Also verify appstore certificates
    match(
      type: "appstore",
      app_identifier: ["xyz.russ.russ5", "xyz.russ.russ5.Extension"],
      readonly: true,
      verbose: true
    )
    
    UI.success("Successfully verified access to certificates repository!")
  end
  
  # Build the Safari extension
  desc "Build Safari extension with proper certificates"
  lane :build_extension do
    # Validate required environment variables
    validate_required_env_vars
    
    # Create build directories with absolute paths
    sh("mkdir -p #{Dir.pwd}/build/logs #{Dir.pwd}/build/derived #{Dir.pwd}/build/ipa")
    
    # Get certificates and profiles
    UI.message("Getting certificates and profiles...")
    match(
      type: "development",
      app_identifier: ["xyz.russ.russ5", "xyz.russ.russ5.Extension"],
      readonly: true,
      verbose: true
    )
    
    # Build the app for development
    UI.message("Building Safari extension...")
    gym(
      project: "#{Dir.pwd}/russ5.xcodeproj",
      scheme: "russ5",
      configuration: "Debug",
      export_method: "development",
      export_options: {
        provisioningProfiles: {
          "xyz.russ.russ5": "match Development xyz.russ.russ5",
          "xyz.russ.russ5.Extension": "match Development xyz.russ.russ5.Extension"
        }
      },
      clean: true,
      output_directory: "#{Dir.pwd}/build/ipa",
      output_name: "russ5-debug.ipa",
      include_symbols: true,
      include_bitcode: false
    )
    
    UI.success("Successfully built Safari extension!")
  end
  
  # Run UI tests on BrowserStack
  desc "Run UI tests on BrowserStack"
  lane :run_ui_tests do
    # Validate required environment variables
    validate_required_env_vars
    
    # Validate BrowserStack environment variables
    validate_browserstack_env_vars
    
    # Create test suite for BrowserStack
    UI.message("Creating BrowserStack test suite...")
    sh("node #{Dir.pwd}/scripts/create-browserstack-test-suite.js")
    
    # Verify test suite was created
    unless File.exist?("#{Dir.pwd}/dist/test-suite.zip")
      UI.user_error!("Failed to create BrowserStack test suite")
    end
    
    # Upload test suite to BrowserStack and run tests
    UI.message("Running tests on BrowserStack...")
    sh("npm run browserstack-upload-testsuite")
    sh("npm run browserstack-run-tests")
    
    # Check test results
    sh("npm run browserstack-check-results")
    
    UI.success("Successfully ran UI tests on BrowserStack!")
  end
  
  # Deploy to TestFlight
  desc "Deploy to TestFlight"
  lane :beta do
    # Validate required environment variables
    validate_required_env_vars
    
    # Get certificates and profiles for App Store
    UI.message("Getting certificates and profiles for App Store...")
    match(
      type: "appstore",
      app_identifier: ["xyz.russ.russ5", "xyz.russ.russ5.Extension"],
      readonly: true,
      verbose: true
    )
    
    # Increment build number
    build_number = latest_testflight_build_number(
      app_identifier: "xyz.russ.russ5",
      api_key_path: api_key_path
    ) + 1
    
    increment_build_number(
      build_number: build_number,
      xcodeproj: "#{Dir.pwd}/russ5.xcodeproj"
    )
    
    # Build the app for App Store
    UI.message("Building app for TestFlight...")
    gym(
      project: "#{Dir.pwd}/russ5.xcodeproj",
      scheme: "russ5",
      configuration: "Release",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          "xyz.russ.russ5": "match AppStore xyz.russ.russ5",
          "xyz.russ.russ5.Extension": "match AppStore xyz.russ.russ5.Extension"
        }
      },
      clean: true,
      output_directory: "#{Dir.pwd}/build/ipa",
      output_name: "russ5.ipa"
    )
    
    # Upload to TestFlight
    UI.message("Uploading to TestFlight...")
    pilot(
      api_key_path: api_key_path,
      skip_waiting_for_build_processing: true,
      ipa: "#{Dir.pwd}/build/ipa/russ5.ipa"
    )
    
    UI.success("Successfully deployed to TestFlight!")
  end
  
  # Deploy to App Store
  desc "Deploy to App Store"
  lane :release do
    # Validate required environment variables
    validate_required_env_vars
    
    # Get certificates and profiles for App Store
    UI.message("Getting certificates and profiles for App Store...")
    match(
      type: "appstore",
      app_identifier: ["xyz.russ.russ5", "xyz.russ.russ5.Extension"],
      readonly: true,
      verbose: true
    )
    
    # Increment build number
    build_number = latest_testflight_build_number(
      app_identifier: "xyz.russ.russ5",
      api_key_path: api_key_path
    ) + 1
    
    increment_build_number(
      build_number: build_number,
      xcodeproj: "#{Dir.pwd}/russ5.xcodeproj"
    )
    
    # Build the app for App Store
    UI.message("Building app for App Store...")
    gym(
      project: "#{Dir.pwd}/russ5.xcodeproj",
      scheme: "russ5",
      configuration: "Release",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          "xyz.russ.russ5": "match AppStore xyz.russ.russ5",
          "xyz.russ.russ5.Extension": "match AppStore xyz.russ.russ5.Extension"
        }
      },
      clean: true,
      output_directory: "#{Dir.pwd}/build/ipa",
      output_name: "russ5.ipa"
    )
    
    # Upload to App Store
    UI.message("Uploading to App Store...")
    deliver(
      api_key_path: api_key_path,
      skip_screenshots: true,
      skip_metadata: false,
      force: true,
      submit_for_review: true,
      automatic_release: true,
      ipa: "#{Dir.pwd}/build/ipa/russ5.ipa"
    )
    
    UI.success("Successfully deployed to App Store!")
  end
  
  # Helper method to validate required environment variables
  private_lane :validate_required_env_vars do
    required_vars = [
      "MATCH_PASSWORD",
      "FASTLANE_APPLE_ID",
      "TEAM_ID"
    ]
    
    missing_vars = required_vars.select { |var| ENV[var].nil? || ENV[var].empty? }
    
    unless missing_vars.empty?
      UI.user_error!("Missing required environment variables: #{missing_vars.join(', ')}")
    end
  end
  
  # Helper method to validate BrowserStack environment variables
  private_lane :validate_browserstack_env_vars do
    required_vars = [
      "BROWSERSTACK_USERNAME",
      "BROWSERSTACK_ACCESS_KEY",
      "BROWSERSTACK_APP_ID"
    ]
    
    missing_vars = required_vars.select { |var| ENV[var].nil? || ENV[var].empty? }
    
    unless missing_vars.empty?
      UI.user_error!("Missing required BrowserStack environment variables: #{missing_vars.join(', ')}")
    end
  end
  
  # Helper method to get the App Store Connect API key path
  def api_key_path
    required_vars = [
      "APP_STORE_CONNECT_API_KEY_CONTENT",
      "APP_STORE_CONNECT_API_KEY_ID",
      "APP_STORE_CONNECT_API_KEY_ISSUER_ID"
    ]
    
    missing_vars = required_vars.select { |var| ENV[var].nil? || ENV[var].empty? }
    
    unless missing_vars.empty?
      UI.user_error!("Missing required App Store Connect API key variables: #{missing_vars.join(', ')}")
    end
    
    # Create a temporary file with the API key
    api_key_path = "/tmp/app_store_connect_api_key.p8"
    File.write(api_key_path, ENV["APP_STORE_CONNECT_API_KEY_CONTENT"])
    
    # Set up the App Store Connect API key
    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
      key_filepath: api_key_path,
      duration: 1200, # 20 minutes
      in_house: false
    )
    
    return api_key_path
  end
end
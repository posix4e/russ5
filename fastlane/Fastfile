default_platform(:ios)

platform :ios do
  # Validate certificates and profiles
  desc "Verify certificates and profiles access"
  lane :verify_certificates do
    # Validate required environment variables
    validate_required_env_vars
    
    # Log environment information
    UI.message("Environment information:")
    UI.message("TEAM_ID: #{ENV['TEAM_ID']}")
    UI.message("MATCH_GIT_URL: #{ENV['MATCH_GIT_URL'] ? ENV['MATCH_GIT_URL'][0..15] + '...' : 'Not set'}")
    UI.message("FASTLANE_APPLE_ID: #{ENV['FASTLANE_APPLE_ID'] ? ENV['FASTLANE_APPLE_ID'][0..5] + '...' : 'Not set'}")
    
    # Log Xcode information
    UI.message("Xcode information:")
    sh("xcodebuild -version", log: true)
    
    # Log project information
    UI.message("Project information:")
    begin
      sh("xcodebuild -project #{Dir.pwd}/russ5.xcodeproj -list", log: true)
    rescue => e
      UI.error("Failed to list project information: #{e.message}")
      UI.message("Checking if project exists:")
      sh("ls -la #{Dir.pwd}", log: true)
      sh("find #{Dir.pwd} -name '*.xcodeproj'", log: true)
    end
    
    # Verify access to certificates repository
    UI.message("Verifying access to certificates repository...")
    
    # Use match to verify access to certificates
    begin
      UI.message("Checking development certificates...")
      match(
        type: "development",
        app_identifier: ["xyz.russ.russ5", "xyz.russ.russ5.Extension"],
        readonly: true,
        verbose: true
      )
      
      # Also verify appstore certificates
      UI.message("Checking App Store certificates...")
      match(
        type: "appstore",
        app_identifier: ["xyz.russ.russ5", "xyz.russ.russ5.Extension"],
        readonly: true,
        verbose: true
      )
      
      UI.success("Successfully verified access to certificates repository!")
    rescue => e
      UI.error("Certificate verification failed: #{e.message}")
      UI.error("Full error: #{e.backtrace.join("\n")}")
      
      # Check if keychain is accessible
      UI.message("Checking keychain access:")
      sh("security list-keychains", log: true)
      sh("security find-identity -v -p codesigning || echo 'No certificates found'", log: true)
      
      # Re-raise the error to fail the lane
      raise e
    end
  end
  
  # Build the Safari extension
  desc "Build Safari extension with proper certificates"
  lane :build_extension do
    # Validate required environment variables
    validate_required_env_vars
    
    # Create build directories with absolute paths
    sh("mkdir -p #{Dir.pwd}/build/logs #{Dir.pwd}/build/derived #{Dir.pwd}/build/ipa")
    
    # Log build environment
    UI.message("Build environment:")
    UI.message("Working directory: #{Dir.pwd}")
    UI.message("Xcode path: #{ENV['DEVELOPER_DIR'] || 'Not set'}")
    
    # Check project existence
    UI.message("Checking project existence:")
    project_path = "#{Dir.pwd}/russ5.xcodeproj"
    if File.directory?(project_path)
      UI.success("Project exists at: #{project_path}")
    else
      UI.error("Project not found at: #{project_path}")
      UI.message("Searching for Xcode projects:")
      sh("find #{Dir.pwd} -name '*.xcodeproj'", log: true)
      UI.user_error!("Cannot continue without project")
    end
    
    # Get certificates and profiles
    UI.message("Getting certificates and profiles...")
    begin
      match(
        type: "development",
        app_identifier: ["xyz.russ.russ5", "xyz.russ.russ5.Extension"],
        readonly: true,
        verbose: true
      )
    rescue => e
      UI.error("Failed to get certificates: #{e.message}")
      UI.error("Full error: #{e.backtrace.join("\n")}")
      
      # Check keychain status
      UI.message("Checking keychain status:")
      sh("security list-keychains", log: true)
      sh("security find-identity -v -p codesigning || echo 'No certificates found'", log: true)
      
      UI.user_error!("Cannot continue without proper certificates")
    end
    
    # Check if provisioning profiles exist
    UI.message("Checking provisioning profiles:")
    sh("ls -la ~/Library/MobileDevice/Provisioning\\ Profiles/ || echo 'No provisioning profiles directory'", log: true)
    
    # Build the app for development
    UI.message("Building Safari extension...")
    begin
      gym(
        project: project_path,
        scheme: "russ5",
        configuration: "Debug",
        export_method: "development",
        export_options: {
          provisioningProfiles: {
            "xyz.russ.russ5": "match Development xyz.russ.russ5",
            "xyz.russ.russ5.Extension": "match Development xyz.russ.russ5.Extension"
          }
        },
        clean: true,
        output_directory: "#{Dir.pwd}/build/ipa",
        output_name: "russ5-debug.ipa",
        include_symbols: true,
        include_bitcode: false,
        buildlog_path: "#{Dir.pwd}/build/logs",
        xcargs: "DEVELOPMENT_TEAM=#{ENV['TEAM_ID']}"
      )
      
      UI.success("Successfully built Safari extension!")
    rescue => e
      UI.error("Build failed: #{e.message}")
      UI.error("Full error: #{e.backtrace.join("\n")}")
      
      # Try to get more build information
      UI.message("Checking build logs:")
      sh("find #{Dir.pwd}/build/logs -type f -name '*.log' | xargs ls -la", log: true)
      sh("find #{Dir.pwd}/build/logs -type f -name '*.log' | xargs tail -n 50", log: true)
      
      # Check for specific errors
      UI.message("Checking for common errors:")
      sh("find #{Dir.pwd}/build/logs -type f -name '*.log' | xargs grep -i 'error:' || echo 'No specific errors found'", log: true)
      sh("find #{Dir.pwd}/build/logs -type f -name '*.log' | xargs grep -i 'no profiles' || echo 'No profile issues found'", log: true)
      sh("find #{Dir.pwd}/build/logs -type f -name '*.log' | xargs grep -i 'no accounts' || echo 'No account issues found'", log: true)
      
      UI.user_error!("Build failed - cannot continue")
    end
  end
  
  # Run UI tests on BrowserStack
  desc "Run UI tests on BrowserStack"
  lane :run_ui_tests do
    # Validate required environment variables
    validate_required_env_vars
    
    # Validate BrowserStack environment variables
    validate_browserstack_env_vars
    
    # Create test suite for BrowserStack
    UI.message("Creating BrowserStack test suite...")
    sh("node #{Dir.pwd}/scripts/create-browserstack-test-suite.js")
    
    # Verify test suite was created
    unless File.exist?("#{Dir.pwd}/dist/test-suite.zip")
      UI.user_error!("Failed to create BrowserStack test suite")
    end
    
    # Upload test suite to BrowserStack and run tests
    UI.message("Running tests on BrowserStack...")
    sh("npm run browserstack-upload-testsuite")
    sh("npm run browserstack-run-tests")
    
    # Check test results
    sh("npm run browserstack-check-results")
    
    UI.success("Successfully ran UI tests on BrowserStack!")
  end
  
  # Deploy to TestFlight
  desc "Deploy to TestFlight"
  lane :beta do
    # Validate required environment variables
    validate_required_env_vars
    
    # Get certificates and profiles for App Store
    UI.message("Getting certificates and profiles for App Store...")
    match(
      type: "appstore",
      app_identifier: ["xyz.russ.russ5", "xyz.russ.russ5.Extension"],
      readonly: true,
      verbose: true
    )
    
    # Increment build number
    build_number = latest_testflight_build_number(
      app_identifier: "xyz.russ.russ5",
      api_key_path: api_key_path
    ) + 1
    
    increment_build_number(
      build_number: build_number,
      xcodeproj: "#{Dir.pwd}/russ5.xcodeproj"
    )
    
    # Build the app for App Store
    UI.message("Building app for TestFlight...")
    gym(
      project: "#{Dir.pwd}/russ5.xcodeproj",
      scheme: "russ5",
      configuration: "Release",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          "xyz.russ.russ5": "match AppStore xyz.russ.russ5",
          "xyz.russ.russ5.Extension": "match AppStore xyz.russ.russ5.Extension"
        }
      },
      clean: true,
      output_directory: "#{Dir.pwd}/build/ipa",
      output_name: "russ5.ipa"
    )
    
    # Upload to TestFlight
    UI.message("Uploading to TestFlight...")
    pilot(
      api_key_path: api_key_path,
      skip_waiting_for_build_processing: true,
      ipa: "#{Dir.pwd}/build/ipa/russ5.ipa"
    )
    
    UI.success("Successfully deployed to TestFlight!")
  end
  
  # Deploy to App Store
  desc "Deploy to App Store"
  lane :release do
    # Validate required environment variables
    validate_required_env_vars
    
    # Get certificates and profiles for App Store
    UI.message("Getting certificates and profiles for App Store...")
    match(
      type: "appstore",
      app_identifier: ["xyz.russ.russ5", "xyz.russ.russ5.Extension"],
      readonly: true,
      verbose: true
    )
    
    # Increment build number
    build_number = latest_testflight_build_number(
      app_identifier: "xyz.russ.russ5",
      api_key_path: api_key_path
    ) + 1
    
    increment_build_number(
      build_number: build_number,
      xcodeproj: "#{Dir.pwd}/russ5.xcodeproj"
    )
    
    # Build the app for App Store
    UI.message("Building app for App Store...")
    gym(
      project: "#{Dir.pwd}/russ5.xcodeproj",
      scheme: "russ5",
      configuration: "Release",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          "xyz.russ.russ5": "match AppStore xyz.russ.russ5",
          "xyz.russ.russ5.Extension": "match AppStore xyz.russ.russ5.Extension"
        }
      },
      clean: true,
      output_directory: "#{Dir.pwd}/build/ipa",
      output_name: "russ5.ipa"
    )
    
    # Upload to App Store
    UI.message("Uploading to App Store...")
    deliver(
      api_key_path: api_key_path,
      skip_screenshots: true,
      skip_metadata: false,
      force: true,
      submit_for_review: true,
      automatic_release: true,
      ipa: "#{Dir.pwd}/build/ipa/russ5.ipa"
    )
    
    UI.success("Successfully deployed to App Store!")
  end
  
  # Helper method to validate required environment variables
  private_lane :validate_required_env_vars do
    required_vars = [
      "MATCH_PASSWORD",
      "FASTLANE_APPLE_ID",
      "TEAM_ID"
    ]
    
    missing_vars = required_vars.select { |var| ENV[var].nil? || ENV[var].empty? }
    
    unless missing_vars.empty?
      UI.user_error!("Missing required environment variables: #{missing_vars.join(', ')}")
    end
  end
  
  # Helper method to validate BrowserStack environment variables
  private_lane :validate_browserstack_env_vars do
    required_vars = [
      "BROWSERSTACK_USERNAME",
      "BROWSERSTACK_ACCESS_KEY",
      "BROWSERSTACK_APP_ID"
    ]
    
    missing_vars = required_vars.select { |var| ENV[var].nil? || ENV[var].empty? }
    
    unless missing_vars.empty?
      UI.user_error!("Missing required BrowserStack environment variables: #{missing_vars.join(', ')}")
    end
  end
  
  # Helper method to get the App Store Connect API key path
  def api_key_path
    required_vars = [
      "APP_STORE_CONNECT_API_KEY_CONTENT",
      "APP_STORE_CONNECT_API_KEY_ID",
      "APP_STORE_CONNECT_API_KEY_ISSUER_ID"
    ]
    
    missing_vars = required_vars.select { |var| ENV[var].nil? || ENV[var].empty? }
    
    unless missing_vars.empty?
      UI.user_error!("Missing required App Store Connect API key variables: #{missing_vars.join(', ')}")
    end
    
    # Create a temporary file with the API key
    api_key_path = "/tmp/app_store_connect_api_key.p8"
    File.write(api_key_path, ENV["APP_STORE_CONNECT_API_KEY_CONTENT"])
    
    # Set up the App Store Connect API key
    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
      key_filepath: api_key_path,
      duration: 1200, # 20 minutes
      in_house: false
    )
    
    return api_key_path
  end
end